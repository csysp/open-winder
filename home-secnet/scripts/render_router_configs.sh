#!/usr/bin/env bash
set -euo pipefail; IFS=$'\n\t'
# Purpose: Render router configuration files into home-secnet/render/.
# Inputs: .env via scripts/lib/env.sh; VERBOSE (optional)
# Outputs: files under home-secnet/render/
# Side effects: Writes render artifacts.

usage() {
  cat <<'USAGE'
Usage: render_router_configs.sh
  Renders router configs/templates into home-secnet/render/.

Environment:
  VERBOSE=1   Enable verbose logging
USAGE
}

if [[ "${1:-}" =~ ^(-h|--help)$ ]]; then
  usage; exit 0
fi
# shellcheck source=scripts/lib/log.sh
# shellcheck source=home-secnet/scripts/lib/log.sh
LIB_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")/lib" && pwd)/log.sh"
if [[ -f "$LIB_PATH" ]]; then
  # shellcheck disable=SC1090
  source "$LIB_PATH"
fi

log_info "[08] Rendering router configs from .env and generating keys..."
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
# Export env vars so templating tools (envsubst/perl) can see them
set -a
source "$ROOT_DIR/.env"
set +a

mkdir -p "$ROOT_DIR/render/router/configs" "$ROOT_DIR/clients"

# Generate WireGuard server keys if absent
WG_DIR="$ROOT_DIR/render/wg"
mkdir -p "$WG_DIR"
if [[ ! -f "$WG_DIR/privatekey" ]]; then
  echo "[08] Generating WireGuard keypair..."
  umask 077
  wg genkey | tee "$WG_DIR/privatekey" | wg pubkey > "$WG_DIR/publickey"
fi
WG_PRIVATE_KEY=$(cat "$WG_DIR/privatekey")
WG_PUBLIC_KEY=$(cat "$WG_DIR/publickey")
export WG_PRIVATE_KEY WG_PUBLIC_KEY

# Helpers for CIDR handling
prefix_len() { echo "$1" | awk -F'/' '{print $2}'; }
net_addr() { echo "$1" | awk -F'/' '{print $1}'; }
mask_from_prefix() {
  local p="$1"; local m=(); local i
  for ((i=0; i<4; i++)); do
    local bits=$(( p>=8 ? 8 : (p>0 ? p : 0) ))
    m+=( $(( 256 - 2**(8-bits) )) )
    p=$(( p-bits ))
  done
  printf "%d.%d.%d.%d\n" "${m[@]}"
}

# Write env-vars for templates
cat > "$ROOT_DIR/router/configs/env-vars.sh" <<EOF
# Autogenerated by render_router_configs.sh
export ISP_WAN_TYPE=${ISP_WAN_TYPE}
export WAN_STATIC_IP=${WAN_STATIC_IP}
export WAN_STATIC_GW=${WAN_STATIC_GW}
export WAN_STATIC_DNS="${WAN_STATIC_DNS}"
export WG_PORT=${WG_PORT}
export WG_NET=${WG_NET}
export WG_SERVER_IP=${WG_SERVER_IP}
export WG_ALLOWED_IPS="${WG_ALLOWED_IPS}"
export WG_PERSISTENT_KEEPALIVE=${WG_PERSISTENT_KEEPALIVE}
export WG_DNS=${WG_DNS}
# VLAN variables (only export if USE_VLANS=true)
if [[ "${USE_VLANS:-false}" == "true" ]]; then
  export VLAN_TRUSTED=${VLAN_TRUSTED}
  export VLAN_IOT=${VLAN_IOT}
  export VLAN_GUEST=${VLAN_GUEST}
  export VLAN_LAB=${VLAN_LAB}
  export NET_IOT=${NET_IOT}
  export NET_GUEST=${NET_GUEST}
  export NET_LAB=${NET_LAB}
  export GW_IOT=${GW_IOT}
  export GW_GUEST=${GW_GUEST}
  export GW_LAB=${GW_LAB}
  export DHCP_IOT_RANGE="${DHCP_IOT_RANGE}"
  export DHCP_GUEST_RANGE="${DHCP_GUEST_RANGE}"
  export DHCP_LAB_RANGE="${DHCP_LAB_RANGE}"
fi
# Common variables (always exported)
export NET_TRUSTED=${NET_TRUSTED}
export GW_TRUSTED=${GW_TRUSTED}
export DHCP_TRUSTED_RANGE="${DHCP_TRUSTED_RANGE}"
export DNS_RECURSORS="${DNS_RECURSORS}"
export ROUTER_WAN_IF=${ROUTER_WAN_IF}
export ROUTER_LAN_IF=${ROUTER_LAN_IF}
export DNS_STACK=${DNS_STACK}
export WG_PRIVATE_KEY=${WG_PRIVATE_KEY}
export WG_PUBLIC_KEY=${WG_PUBLIC_KEY}
EOF

render() {
  local src="$1" dst="$2"
  set +e
  if command -v envsubst >/dev/null 2>&1; then
    envsubst < "$src" > "$dst"
  else
    # Fallback with perl env substitution for ${VAR}
    perl -M5.010 -pe 's/\$\{([A-Z0-9_]+)\}/defined $ENV{$1} ? $ENV{$1} : ""/ge' "$src" > "$dst"
  fi
  set -e
}

if [[ "${USE_VLANS:-false}" == "true" ]]; then
  # Choose nftables template (SPA vs default)
  if [[ "${SPA_ENABLE:-false}" == "true" ]]; then
    render "$ROOT_DIR/router/configs/nftables.spa.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  else
    render "$ROOT_DIR/router/configs/nftables.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  fi
  for f in wg0.conf suricata.yaml tc-shaping.sh; do
    render "$ROOT_DIR/router/configs/$f" "$ROOT_DIR/render/router/configs/$f"
  done
  # Generate DHCP for VLANs with derived masks
  T_PREF=$(prefix_len "$NET_TRUSTED"); T_MASK=$(mask_from_prefix "$T_PREF"); T_NET=$(net_addr "$NET_TRUSTED")
  I_PREF=$(prefix_len "$NET_IOT");     I_MASK=$(mask_from_prefix "$I_PREF"); I_NET=$(net_addr "$NET_IOT")
  G_PREF=$(prefix_len "$NET_GUEST");   G_MASK=$(mask_from_prefix "$G_PREF"); G_NET=$(net_addr "$NET_GUEST")
  L_PREF=$(prefix_len "$NET_LAB");     L_MASK=$(mask_from_prefix "$L_PREF"); L_NET=$(net_addr "$NET_LAB")
  cat > "$ROOT_DIR/render/router/configs/dhcpd.conf" <<EOF
# ISC DHCP (VLANs)
default-lease-time 600;
max-lease-time 7200;
authoritative;

subnet ${T_NET} netmask ${T_MASK} {
  option routers ${GW_TRUSTED};
  option domain-name-servers ${GW_TRUSTED};
  range ${DHCP_TRUSTED_RANGE};
}

subnet ${I_NET} netmask ${I_MASK} {
  option routers ${GW_IOT};
  option domain-name-servers ${GW_IOT};
  range ${DHCP_IOT_RANGE};
}

subnet ${G_NET} netmask ${G_MASK} {
  option routers ${GW_GUEST};
  option domain-name-servers ${GW_GUEST};
  range ${DHCP_GUEST_RANGE};
}

subnet ${L_NET} netmask ${L_MASK} {
  option routers ${GW_LAB};
  option domain-name-servers ${GW_LAB};
  range ${DHCP_LAB_RANGE};
}
EOF
  if [[ "${DNS_STACK}" == "unbound" ]]; then
    render "$ROOT_DIR/router/configs/unbound.conf" "$ROOT_DIR/render/router/configs/unbound.conf"
  else
    render "$ROOT_DIR/router/configs/adguard-home.yaml" "$ROOT_DIR/render/router/configs/adguard-home.yaml"
  fi
else
  # Flat LAN templates
  if [[ "${SPA_ENABLE:-false}" == "true" ]]; then
    render "$ROOT_DIR/router/configs/nftables.flat.spa.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  else
    render "$ROOT_DIR/router/configs/nftables.flat.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  fi
  render "$ROOT_DIR/router/configs/suricata.flat.yaml" "$ROOT_DIR/render/router/configs/suricata.yaml"
  render "$ROOT_DIR/router/configs/tc-shaping.flat.sh" "$ROOT_DIR/render/router/configs/tc-shaping.sh"
  render "$ROOT_DIR/router/configs/wg0.conf" "$ROOT_DIR/render/router/configs/wg0.conf"
  # Generate DHCP for flat LAN
  TR_PREF=$(prefix_len "$NET_TRUSTED"); TR_MASK=$(mask_from_prefix "$TR_PREF"); TR_NET=$(net_addr "$NET_TRUSTED")
  cat > "$ROOT_DIR/render/router/configs/dhcpd.conf" <<EOF
# ISC DHCP (flat LAN)
default-lease-time 600;
max-lease-time 7200;
authoritative;
subnet ${TR_NET} netmask ${TR_MASK} {
  option routers ${GW_TRUSTED};
  option domain-name-servers ${GW_TRUSTED};
  range ${DHCP_TRUSTED_RANGE};
}
EOF
  if [[ "${DNS_STACK}" == "unbound" ]]; then
    render "$ROOT_DIR/router/configs/unbound.flat.conf" "$ROOT_DIR/render/router/configs/unbound.conf"
  else
    render "$ROOT_DIR/router/configs/adguard-home.flat.yaml" "$ROOT_DIR/render/router/configs/adguard-home.yaml"
  fi
fi

# Optional: QUIC wrapper (Hysteria2)
if [[ "${WRAP_MODE:-none}" == "hysteria2" ]]; then
  render "$ROOT_DIR/router/configs/hysteria2-server.yaml" "$ROOT_DIR/render/router/configs/hysteria2.yaml"
  # Client sample (run on the client device)
  cat > "$ROOT_DIR/clients/hysteria2-client.yaml" <<EOF
server: ${WRAP_DOMAIN:-<server_ip>}:${WRAP_LISTEN_PORT}
obfs:
  type: salamander
  salamander:
    password: ${WRAP_PASSWORD}
auth: ${WRAP_PASSWORD}
tls:
  sni: ${WRAP_DOMAIN}
  insecure: true
quic:
  init_streams: 64
  max_idle_timeout: 90s
EOF
  echo "[08] QUIC wrapper enabled. Use hysteria2 client to wrap WG UDP over QUIC."
fi

# SPA configs
# SPA configs
if [[ "${SPA_ENABLE:-false}" == "true" ]]; then
  if [[ "${SPA_MODE:-pqkem}" == "pqkem" ]]; then
    echo "[08] SPA mode: PQ-KEM (Kyber + HMAC)"
    SPAQ_DIR="$ROOT_DIR/render/spa/pq"
    mkdir -p "$SPAQ_DIR" "$ROOT_DIR/render/router/systemd"
    # Generate PSK if missing
    if [[ ! -f "$SPAQ_DIR/psk.bin" ]]; then
      umask 077
      head -c 32 /dev/urandom > "$SPAQ_DIR/psk.bin"
    fi
    # Generate Kyber keypair using local built tool if available
    SPA_BIN="$ROOT_DIR/router/spa-pq/target/release/home-secnet-spa-pq"
    if [[ -x "$SPA_BIN" ]]; then
      if [[ ! -f "$SPAQ_DIR/kem_priv.bin" || ! -f "$SPAQ_DIR/kem_pub.bin" ]]; then
        "$SPA_BIN" gen-keys --priv-out "$SPAQ_DIR/kem_priv.bin" --pub-out "$SPAQ_DIR/kem_pub.bin"
      fi
    else
      echo "[08] WARNING: spa-pq binary not found at $SPA_BIN. Run 'make spa' to build locally. Deferring keypair generation to apply step."
    fi
    # Prepare client JSON
    PSK_B64=$(base64 -w0 < "$SPAQ_DIR/psk.bin" 2>/dev/null || base64 < "$SPAQ_DIR/psk.bin")
    if [[ -f "$SPAQ_DIR/kem_pub.bin" ]]; then
      PUB_B64=$(base64 -w0 < "$SPAQ_DIR/kem_pub.bin" 2>/dev/null || base64 < "$SPAQ_DIR/kem_pub.bin")
    else
      PUB_B64="TO_BE_FILLED_AFTER_DEPLOY"
    fi
    cat > "$ROOT_DIR/clients/spa-pq-client.json" <<EOF
{
  "router_host": "<YOUR_PUB_IP>",
  "spa_port": ${SPA_PQ_PORT:-62201},
  "wg_port": ${WG_PORT},
  "kem_pub_b64": "${PUB_B64}",
  "psk_b64": "${PSK_B64}"
}
EOF
    # Render systemd unit with ExecStart args
    cat > "$ROOT_DIR/render/router/systemd/spa-pq.service" <<EOF
[Unit]
Description=Home-SecNet PQ-KEM SPA Daemon
After=network-online.target nftables.service
Wants=network-online.target nftables.service

[Service]
ExecStart=/usr/local/bin/home-secnet-spa-pq run \
  --listen 0.0.0.0:${SPA_PQ_PORT:-62201} \
  --wg-port ${WG_PORT} \
  --kem-priv /etc/spa/kem_priv.bin \
  --psk-file ${SPA_PQ_PSK_FILE:-/etc/spa/psk.bin} \
  --open-secs ${SPA_PQ_OPEN_SECS:-45} \
  --window-secs ${SPA_PQ_WINDOW_SECS:-30} \
  --nft-table inet \
  --nft-chain wg_spa_allow
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
Restart=on-failure
RestartSec=1s

[Install]
WantedBy=multi-user.target
EOF
    echo "[08] PQ-KEM SPA artifacts prepared under render/spa/pq and render/router/systemd/."
  else
    echo "[08] Legacy fwknop mode is no longer supported. Set SPA_MODE=pqkem."
    exit 1
  fi
fi

# Optional: double-hop wg1 to exit node
if [[ "${DOUBLE_HOP_ENABLE:-false}" == "true" ]]; then
  WG2_DIR="$ROOT_DIR/render/wg2"
  mkdir -p "$WG2_DIR"
  if [[ -z "${WG2_PRIVATE_KEY:-}" ]]; then
    echo "[06] Generating wg1 private key..."
    umask 077
    wg genkey > "$WG2_DIR/privatekey"
    WG2_PRIVATE_KEY=$(cat "$WG2_DIR/privatekey")
    # Persist into .env for future renders
    awk -v k="WG2_PRIVATE_KEY" -v v="$WG2_PRIVATE_KEY" 'BEGIN{FS=OFS="="} $1==k {$0=k"="v} {print}' "$ROOT_DIR/.env" > "$ROOT_DIR/.env.tmp" && mv "$ROOT_DIR/.env.tmp" "$ROOT_DIR/.env"
  fi
  export WG2_PRIVATE_KEY
  render "$ROOT_DIR/router/configs/wg1.conf.template" "$ROOT_DIR/render/router/configs/wg1.conf"
  echo "[08] Double-hop enabled. Remember to configure the exit node peer to accept ${WG2_ADDRESS}."
fi

# Enforce QUIC-only if requested: remove any WG UDP allow line from nftables
if [[ "${WRAP_ENFORCE:-false}" == "true" ]]; then
  nftf="$ROOT_DIR/render/router/configs/nftables.conf"
  if [[ -f "$nftf" ]]; then
    # Remove only direct WG accept rules, not SPA-gated ones
    sed -i -E "/udp dport ${WG_PORT}[^@]*$/d" "$nftf"
  fi
fi

# Generate netplan based on ISP_WAN_TYPE
NP_OUT="$ROOT_DIR/render/router/configs/netplan.yaml"
cat > "$NP_OUT" <<EOF
# Generated by render_router_configs.sh
network:
  version: 2
  renderer: networkd
  ethernets:
    ${ROUTER_WAN_IF}:
      optional: true
$(if [[ "$ISP_WAN_TYPE" == "static" ]]; then cat <<EOS
      dhcp4: false
      addresses: [${WAN_STATIC_IP}]
      routes:
        - to: 0.0.0.0/0
          via: ${WAN_STATIC_GW}
      nameservers:
        addresses: [${WAN_STATIC_DNS}]
EOS
else
  cat <<EOS
      dhcp4: true
EOS
fi)
    ${ROUTER_LAN_IF}:
      dhcp4: false
      accept-ra: false
$(if [[ "${USE_VLANS:-false}" == "true" ]]; then cat <<EOS
  vlans:
    ${ROUTER_LAN_IF}.${VLAN_TRUSTED}:
      id: ${VLAN_TRUSTED}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_TRUSTED}/$(prefix_len "$NET_TRUSTED")]
    ${ROUTER_LAN_IF}.${VLAN_IOT}:
      id: ${VLAN_IOT}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_IOT}/$(prefix_len "$NET_IOT")]
    ${ROUTER_LAN_IF}.${VLAN_GUEST}:
      id: ${VLAN_GUEST}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_GUEST}/$(prefix_len "$NET_GUEST")]
    ${ROUTER_LAN_IF}.${VLAN_LAB}:
      id: ${VLAN_LAB}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_LAB}/$(prefix_len "$NET_LAB")]
EOS
else
  cat <<EOS
      addresses: [${GW_TRUSTED}/$(prefix_len "$NET_TRUSTED")]
EOS
fi)
EOF

# Sample client
CLIENT_PRIV=$(wg genkey)
cat > "$ROOT_DIR/clients/wg-client1.conf" <<EOF
[Interface]
PrivateKey = ${CLIENT_PRIV}
Address = 10.66.66.2/24
DNS = ${WG_DNS}

[Peer]
PublicKey = ${WG_PUBLIC_KEY}
AllowedIPs = ${WG_ALLOWED_IPS}
Endpoint = <YOUR_PUB_IP>:${WG_PORT}
PersistentKeepalive = ${WG_PERSISTENT_KEEPALIVE}
EOF

# Local secure logging configuration
cat > "$ROOT_DIR/render/router/configs/rsyslog-secure.conf" <<EOF
# Secure local logging configuration
# Create secure log directory
\$CreateDirs on
\$DirCreateMode 0750
\$FileCreateMode 0640

# Log all system logs to secure directory
*.* /var/log/secure/system.log

# Log authentication events
auth,authpriv.* /var/log/secure/auth.log

# Log kernel messages
kern.* /var/log/secure/kernel.log

# Log mail events
mail.* /var/log/secure/mail.log

# Log cron events
cron.* /var/log/secure/cron.log

# Log daemon events
daemon.* /var/log/secure/daemon.log

# Log local events
local0.* /var/log/secure/local.log
local1.* /var/log/secure/local.log
local2.* /var/log/secure/local.log
local3.* /var/log/secure/local.log
local4.* /var/log/secure/local.log
local5.* /var/log/secure/local.log
local6.* /var/log/secure/local.log
local7.* /var/log/secure/local.log
EOF

echo "[08] Render complete. Artifacts under render/ and clients/."
# Ultralight adjustments
if [[ "${ULTRALIGHT_MODE:-false}" == "true" ]]; then
  export IDS_MODE=none
fi

mkdir -p "$(dirname "$0")/../render" "$(dirname "$0")/../render/etc" "$(dirname "$0")/../render/usr/local/sbin" "$(dirname "$0")/../render/etc/systemd/system"
OUT_ROOT="$(cd "$(dirname "$0")/../render" && pwd)"

if [[ "${ULTRALIGHT_MODE:-false}" != "true" && "${ULTRALIGHT_EXPERIMENTAL:-0}" != "1" ]]; then
  echo "[render] Ultralight disabled (future addition)"
fi

# Derive interface names from .env if present
ROUTER_WAN_IF_DEFAULT="wan0"
ROUTER_LAN_IF_DEFAULT="lan0"
if [[ -f "$(dirname "$0")/../.env" ]]; then
  # shellcheck disable=SC1090
  source "$(dirname "$0")/../.env"
fi
WAN_IF_NAME="${ROUTER_WAN_IF:-$ROUTER_WAN_IF_DEFAULT}"
LAN_IF_NAME="${ROUTER_LAN_IF:-$ROUTER_LAN_IF_DEFAULT}"

# DHCP/DNS selection
if [[ "${DHCP_STACK:-dnsmasq}" == "dnsmasq" ]]; then
  mkdir -p "$OUT_ROOT/etc/dnsmasq.d"
  cat > "$OUT_ROOT/etc/dnsmasq.d/home-secnet.conf" <<'EOF'
# dnsmasq: DHCP only (DNS disabled if Unbound is used)
port=0
domain-needed
bogus-priv
expand-hosts
dhcp-authoritative
# Example VLAN scopes (template):
#dhcp-range=lan0,10.10.10.100,10.10.10.200,255.255.255.0,12h
#dhcp-option=lan0,option:router,10.10.10.1
#dhcp-option=lan0,option:dns-server,10.10.10.1
EOF
fi

if [[ "${DNS_STACK:-adguard}" == "unbound" ]]; then
  mkdir -p "$OUT_ROOT/etc/unbound"
  cat > "$OUT_ROOT/etc/unbound/unbound.conf" <<'EOF'
server:
  verbosity: 0
  interface: 0.0.0.0
  do-ip6: no
  cache-min-ttl: 60
  cache-max-ttl: 86400
  prefetch: yes
  qname-minimisation: yes
  harden-referral-path: yes
  harden-algo-downgrade: yes
  hide-identity: yes
  hide-version: yes
  rrset-roundrobin: yes
  unwanted-reply-threshold: 10000000
  val-permissive-mode: no
  auto-trust-anchor-file: "/var/lib/unbound/root.key"
  tls-cert-bundle: "/etc/ssl/certs/ca-certificates.crt"
  # upstreams (edit to taste)
  forward-zone:
    name: "."
    forward-tls-upstream: yes
    forward-addr: 1.1.1.1@853
    forward-addr: 1.0.0.1@853
EOF
fi

# nftables (ultralight)
if [[ "${NFT_GUARD_ENABLE:-true}" == "true" ]]; then
  mkdir -p "$OUT_ROOT/etc/nftables.d"
  cat > "$OUT_ROOT/etc/nftables.d/ultralight.nft" <<EOF
define WAN = "${WAN_IF_NAME}"
define LAN = "${LAN_IF_NAME}"
define WGPORT = 51820

table inet winder_ultralight {
  sets {
    bogons_v4 { type ipv4_addr; flags interval; auto-merge; }
    naughty_v4 { type ipv4_addr; timeout 10m; }
  }

  chain input_ul {
    type filter hook input priority 10; policy accept;

    iif lo accept
    ct state established,related accept

    # SPA-controlled WG open window
    udp dport $WGPORT jump wg_spa_allow

    # SSH only over WG
    iifname "wg0" tcp dport 22 accept

    # DNS from LAN/WG
    iifname { "$LAN", "wg0" } udp dport 53 accept
    iifname { "$LAN", "wg0" } tcp dport 53 accept

    # Drop bogons on WAN
    iifname "$WAN" ip saddr @bogons_v4 drop

    # Basic ICMP throttling
    ip protocol icmp limit rate over 10/second burst 20 packets drop
    ip6 nexthdr ipv6-icmp limit rate over 10/second burst 20 packets drop

    # Dynamic shun (optional)
    ip saddr @naughty_v4 drop
  }

  chain wg_spa_allow {
    # populated dynamically by SPA daemon
  }

  chain forward_ul {
    type filter hook forward priority 10; policy accept;
    ct state established,related accept

    # LAN -> WAN allowed
    iifname "$LAN" oifname "$WAN" accept

    # Inter-VLAN/LAN policy: deny-by-default; add explicit allows here
  }
}
EOF

  # Minimal bogons include placeholder
  cat > "$OUT_ROOT/etc/nftables.d/bogons.nft" <<'EOF'
add element inet winder_ultralight bogons_v4 {
  0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, 169.254.0.0/16,
  172.16.0.0/12, 192.0.0.0/24, 192.0.2.0/24, 192.168.0.0/16,
  198.18.0.0/15, 198.51.100.0/24, 203.0.113.0/24, 224.0.0.0/4, 240.0.0.0/4
}
EOF
fi

# shaping helper
if [[ "${SHAPING_ENABLE:-true}" == "true" ]]; then
  cat > "$OUT_ROOT/usr/local/sbin/ul_shaping.sh" <<EOF
#!/usr/bin/env bash
set -eo pipefail
WAN_IF="${1:-${WAN_IF_NAME}}"
EGRESS_KBIT="${2:-0}"
INGRESS_KBIT="${3:-0}"

if [[ "$EGRESS_KBIT" -eq 0 ]]; then
  EG=$(ethtool "$WAN_IF" 2>/dev/null | awk '/Speed:/ {gsub(/[^0-9]/,"",$2); print $2*1000}')
  EGRESS_KBIT=${EG:-1000000}
fi
if [[ "$INGRESS_KBIT" -eq 0 ]]; then
  IN=$EGRESS_KBIT
  INGRESS_KBIT=${IN}
fi

tc qdisc replace dev "$WAN_IF" root fq_codel
tc qdisc replace dev "$WAN_IF" handle ffff: ingress
tc filter replace dev "$WAN_IF" parent ffff: protocol all prio 50 u32 match u32 0 0 police rate ${INGRESS_KBIT}kbit burst 64k drop flowid :1
echo "fq_codel on $WAN_IF; ingress cap ${INGRESS_KBIT} kbit; egress fq_codel"
EOF
  chmod +x "$OUT_ROOT/usr/local/sbin/ul_shaping.sh"
fi

# minimal logrotate
mkdir -p "$OUT_ROOT/etc/logrotate.d"
cat > "$OUT_ROOT/etc/logrotate.d/home-secnet" <<'EOF'
/var/log/*.log {
  rotate 7
  daily
  missingok
  notifempty
  compress
  delaycompress
  copytruncate
}
EOF

# stage SPA artifacts if present locally (no network)
mkdir -p "$OUT_ROOT/opt/spa"
if [[ -f "$SCRIPT_DIR/../router/spa-pq/target/release/home-secnet-spa-pq" ]]; then
  cp -f "$SCRIPT_DIR/../router/spa-pq/target/release/home-secnet-spa-pq" "$OUT_ROOT/opt/spa/home-secnet-spa-pq"
fi
if [[ -f "$SCRIPT_DIR/../clients/spa-pq-client/target/release/home-secnet-spa-pq-client" ]]; then
  cp -f "$SCRIPT_DIR/../clients/spa-pq-client/target/release/home-secnet-spa-pq-client" "$OUT_ROOT/opt/spa/home-secnet-spa-pq-client"
fi
for f in token.json token.sig pubkey.gpg cosign.pub cosign.bundle; do
  if [[ -f "$SCRIPT_DIR/../$f" ]]; then cp -f "$SCRIPT_DIR/../$f" "$OUT_ROOT/opt/spa/$f"; fi
done

# optional ultralight health helper
cat > "$OUT_ROOT/usr/local/sbin/ul_health.sh" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
echo "== nftables summary =="
if command -v nft >/dev/null 2>&1; then
  nft list ruleset | sed -n '1,120p' | sed 's/^/  /'
else
  echo "nft not installed"
fi
echo "== DNS =="
systemctl --no-pager --full status unbound 2>/dev/null | head -n 15 || true
systemctl --no-pager --full status dnsmasq 2>/dev/null | head -n 15 || true
echo "== Shaping =="
WAN_DEV=${1:-${WAN_IF_NAME}}
tc qdisc show dev "$WAN_DEV" || true
echo "== WireGuard (port closed by default) =="
ss -lunp | grep -E ':(51820)\s' || echo "WG not listening or port closed (expected until SPA)"
EOF
chmod +x "$OUT_ROOT/usr/local/sbin/ul_health.sh"

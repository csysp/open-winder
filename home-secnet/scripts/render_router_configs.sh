#!/usr/bin/env bash
set -euo pipefail; IFS=$'\n\t'
LIB_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")/lib" && pwd)/log.sh"; [[ -f "$LIB_PATH" ]] && source "$LIB_PATH"

echo "[08] Rendering router configs from .env and generating keys..."
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
# Export env vars so templating tools (envsubst/perl) can see them
set -a
source "$ROOT_DIR/.env"
set +a

mkdir -p "$ROOT_DIR/render/router/configs" "$ROOT_DIR/clients"

# Generate WireGuard server keys if absent
WG_DIR="$ROOT_DIR/render/wg"
mkdir -p "$WG_DIR"
if [[ ! -f "$WG_DIR/privatekey" ]]; then
  echo "[08] Generating WireGuard keypair..."
  umask 077
  wg genkey | tee "$WG_DIR/privatekey" | wg pubkey > "$WG_DIR/publickey"
fi
WG_PRIVATE_KEY=$(cat "$WG_DIR/privatekey")
WG_PUBLIC_KEY=$(cat "$WG_DIR/publickey")
export WG_PRIVATE_KEY WG_PUBLIC_KEY

# Helpers for CIDR handling
prefix_len() { echo "$1" | awk -F'/' '{print $2}'; }
net_addr() { echo "$1" | awk -F'/' '{print $1}'; }
mask_from_prefix() {
  local p="$1"; local m=(); local i
  for ((i=0; i<4; i++)); do
    local bits=$(( p>=8 ? 8 : (p>0 ? p : 0) ))
    m+=( $(( 256 - 2**(8-bits) )) )
    p=$(( p-bits ))
  done
  printf "%d.%d.%d.%d\n" "${m[@]}"
}

# Write env-vars for templates
cat > "$ROOT_DIR/router/configs/env-vars.sh" <<EOF
# Autogenerated by render_router_configs.sh
export ISP_WAN_TYPE=${ISP_WAN_TYPE}
export WAN_STATIC_IP=${WAN_STATIC_IP}
export WAN_STATIC_GW=${WAN_STATIC_GW}
export WAN_STATIC_DNS="${WAN_STATIC_DNS}"
export WG_PORT=${WG_PORT}
export WG_NET=${WG_NET}
export WG_SERVER_IP=${WG_SERVER_IP}
export WG_ALLOWED_IPS="${WG_ALLOWED_IPS}"
export WG_PERSISTENT_KEEPALIVE=${WG_PERSISTENT_KEEPALIVE}
export WG_DNS=${WG_DNS}
# VLAN variables (only export if USE_VLANS=true)
if [[ "${USE_VLANS:-false}" == "true" ]]; then
  export VLAN_TRUSTED=${VLAN_TRUSTED}
  export VLAN_IOT=${VLAN_IOT}
  export VLAN_GUEST=${VLAN_GUEST}
  export VLAN_LAB=${VLAN_LAB}
  export NET_IOT=${NET_IOT}
  export NET_GUEST=${NET_GUEST}
  export NET_LAB=${NET_LAB}
  export GW_IOT=${GW_IOT}
  export GW_GUEST=${GW_GUEST}
  export GW_LAB=${GW_LAB}
  export DHCP_IOT_RANGE="${DHCP_IOT_RANGE}"
  export DHCP_GUEST_RANGE="${DHCP_GUEST_RANGE}"
  export DHCP_LAB_RANGE="${DHCP_LAB_RANGE}"
fi
# Common variables (always exported)
export NET_TRUSTED=${NET_TRUSTED}
export GW_TRUSTED=${GW_TRUSTED}
export DHCP_TRUSTED_RANGE="${DHCP_TRUSTED_RANGE}"
export DNS_RECURSORS="${DNS_RECURSORS}"
export ROUTER_WAN_IF=${ROUTER_WAN_IF}
export ROUTER_LAN_IF=${ROUTER_LAN_IF}
export DNS_STACK=${DNS_STACK}
export WG_PRIVATE_KEY=${WG_PRIVATE_KEY}
export WG_PUBLIC_KEY=${WG_PUBLIC_KEY}
EOF

render() {
  local src="$1" dst="$2"
  set +e
  if command -v envsubst >/dev/null 2>&1; then
    envsubst < "$src" > "$dst"
  else
    # Fallback with perl env substitution for ${VAR}
    perl -M5.010 -pe 's/\$\{([A-Z0-9_]+)\}/defined $ENV{$1} ? $ENV{$1} : ""/ge' "$src" > "$dst"
  fi
  set -e
}

if [[ "${USE_VLANS:-false}" == "true" ]]; then
  # Choose nftables template (SPA vs default)
  if [[ "${SPA_ENABLE:-false}" == "true" ]]; then
    render "$ROOT_DIR/router/configs/nftables.spa.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  else
    render "$ROOT_DIR/router/configs/nftables.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  fi
  for f in wg0.conf suricata.yaml tc-shaping.sh; do
    render "$ROOT_DIR/router/configs/$f" "$ROOT_DIR/render/router/configs/$f"
  done
  # Generate DHCP for VLANs with derived masks
  T_PREF=$(prefix_len "$NET_TRUSTED"); T_MASK=$(mask_from_prefix "$T_PREF"); T_NET=$(net_addr "$NET_TRUSTED")
  I_PREF=$(prefix_len "$NET_IOT");     I_MASK=$(mask_from_prefix "$I_PREF"); I_NET=$(net_addr "$NET_IOT")
  G_PREF=$(prefix_len "$NET_GUEST");   G_MASK=$(mask_from_prefix "$G_PREF"); G_NET=$(net_addr "$NET_GUEST")
  L_PREF=$(prefix_len "$NET_LAB");     L_MASK=$(mask_from_prefix "$L_PREF"); L_NET=$(net_addr "$NET_LAB")
  cat > "$ROOT_DIR/render/router/configs/dhcpd.conf" <<EOF
# ISC DHCP (VLANs)
default-lease-time 600;
max-lease-time 7200;
authoritative;

subnet ${T_NET} netmask ${T_MASK} {
  option routers ${GW_TRUSTED};
  option domain-name-servers ${GW_TRUSTED};
  range ${DHCP_TRUSTED_RANGE};
}

subnet ${I_NET} netmask ${I_MASK} {
  option routers ${GW_IOT};
  option domain-name-servers ${GW_IOT};
  range ${DHCP_IOT_RANGE};
}

subnet ${G_NET} netmask ${G_MASK} {
  option routers ${GW_GUEST};
  option domain-name-servers ${GW_GUEST};
  range ${DHCP_GUEST_RANGE};
}

subnet ${L_NET} netmask ${L_MASK} {
  option routers ${GW_LAB};
  option domain-name-servers ${GW_LAB};
  range ${DHCP_LAB_RANGE};
}
EOF
  if [[ "${DNS_STACK}" == "unbound" ]]; then
    render "$ROOT_DIR/router/configs/unbound.conf" "$ROOT_DIR/render/router/configs/unbound.conf"
  else
    render "$ROOT_DIR/router/configs/adguard-home.yaml" "$ROOT_DIR/render/router/configs/adguard-home.yaml"
  fi
else
  # Flat LAN templates
  if [[ "${SPA_ENABLE:-false}" == "true" ]]; then
    render "$ROOT_DIR/router/configs/nftables.flat.spa.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  else
    render "$ROOT_DIR/router/configs/nftables.flat.conf" "$ROOT_DIR/render/router/configs/nftables.conf"
  fi
  render "$ROOT_DIR/router/configs/suricata.flat.yaml" "$ROOT_DIR/render/router/configs/suricata.yaml"
  render "$ROOT_DIR/router/configs/tc-shaping.flat.sh" "$ROOT_DIR/render/router/configs/tc-shaping.sh"
  render "$ROOT_DIR/router/configs/wg0.conf" "$ROOT_DIR/render/router/configs/wg0.conf"
  # Generate DHCP for flat LAN
  TR_PREF=$(prefix_len "$NET_TRUSTED"); TR_MASK=$(mask_from_prefix "$TR_PREF"); TR_NET=$(net_addr "$NET_TRUSTED")
  cat > "$ROOT_DIR/render/router/configs/dhcpd.conf" <<EOF
# ISC DHCP (flat LAN)
default-lease-time 600;
max-lease-time 7200;
authoritative;
subnet ${TR_NET} netmask ${TR_MASK} {
  option routers ${GW_TRUSTED};
  option domain-name-servers ${GW_TRUSTED};
  range ${DHCP_TRUSTED_RANGE};
}
EOF
  if [[ "${DNS_STACK}" == "unbound" ]]; then
    render "$ROOT_DIR/router/configs/unbound.flat.conf" "$ROOT_DIR/render/router/configs/unbound.conf"
  else
    render "$ROOT_DIR/router/configs/adguard-home.flat.yaml" "$ROOT_DIR/render/router/configs/adguard-home.yaml"
  fi
fi

# Optional: QUIC wrapper (Hysteria2)
if [[ "${WRAP_MODE:-none}" == "hysteria2" ]]; then
  render "$ROOT_DIR/router/configs/hysteria2-server.yaml" "$ROOT_DIR/render/router/configs/hysteria2.yaml"
  # Client sample (run on the client device)
  cat > "$ROOT_DIR/clients/hysteria2-client.yaml" <<EOF
server: ${WRAP_DOMAIN:-<server_ip>}:${WRAP_LISTEN_PORT}
obfs:
  type: salamander
  salamander:
    password: ${WRAP_PASSWORD}
auth: ${WRAP_PASSWORD}
tls:
  sni: ${WRAP_DOMAIN}
  insecure: true
quic:
  init_streams: 64
  max_idle_timeout: 90s
EOF
  echo "[08] QUIC wrapper enabled. Use hysteria2 client to wrap WG UDP over QUIC."
fi

# SPA configs
# SPA configs
if [[ "${SPA_ENABLE:-false}" == "true" ]]; then
  if [[ "${SPA_MODE:-legacy}" == "pqkem" ]]; then
    echo "[08] SPA mode: PQ-KEM (Kyber + HMAC)"
    SPAQ_DIR="$ROOT_DIR/render/spa/pq"
    mkdir -p "$SPAQ_DIR" "$ROOT_DIR/render/router/systemd"
    # Generate PSK if missing
    if [[ ! -f "$SPAQ_DIR/psk.bin" ]]; then
      umask 077
      head -c 32 /dev/urandom > "$SPAQ_DIR/psk.bin"
    fi
    # Generate Kyber keypair using local built tool if available
    SPA_BIN="$ROOT_DIR/router/spa-pq/target/release/home-secnet-spa-pq"
    if [[ -x "$SPA_BIN" ]]; then
      if [[ ! -f "$SPAQ_DIR/kem_priv.bin" || ! -f "$SPAQ_DIR/kem_pub.bin" ]]; then
        "$SPA_BIN" gen-keys --priv-out "$SPAQ_DIR/kem_priv.bin" --pub-out "$SPAQ_DIR/kem_pub.bin"
      fi
    else
      echo "[08] WARNING: spa-pq binary not found at $SPA_BIN. Run 'make spa' to build locally. Deferring keypair generation to apply step."
    fi
    # Prepare client JSON
    PSK_B64=$(base64 -w0 < "$SPAQ_DIR/psk.bin" 2>/dev/null || base64 < "$SPAQ_DIR/psk.bin")
    if [[ -f "$SPAQ_DIR/kem_pub.bin" ]]; then
      PUB_B64=$(base64 -w0 < "$SPAQ_DIR/kem_pub.bin" 2>/dev/null || base64 < "$SPAQ_DIR/kem_pub.bin")
    else
      PUB_B64="TO_BE_FILLED_AFTER_DEPLOY"
    fi
    cat > "$ROOT_DIR/clients/spa-pq-client.json" <<EOF
{
  "router_host": "<YOUR_PUB_IP>",
  "spa_port": ${SPA_PQ_PORT:-62201},
  "wg_port": ${WG_PORT},
  "kem_pub_b64": "${PUB_B64}",
  "psk_b64": "${PSK_B64}"
}
EOF
    # Render systemd unit with ExecStart args
    cat > "$ROOT_DIR/render/router/systemd/spa-pq.service" <<EOF
[Unit]
Description=Home-SecNet PQ-KEM SPA Daemon
After=network-online.target nftables.service
Wants=network-online.target nftables.service

[Service]
ExecStart=/usr/local/bin/home-secnet-spa-pq run \
  --listen 0.0.0.0:${SPA_PQ_PORT:-62201} \
  --wg-port ${WG_PORT} \
  --kem-priv /etc/spa/kem_priv.bin \
  --psk-file ${SPA_PQ_PSK_FILE:-/etc/spa/psk.bin} \
  --open-secs ${SPA_PQ_OPEN_SECS:-45} \
  --window-secs ${SPA_PQ_WINDOW_SECS:-30} \
  --nft-table inet \
  --nft-chain wg_spa_allow
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
Restart=on-failure
RestartSec=1s

[Install]
WantedBy=multi-user.target
EOF
    echo "[08] PQ-KEM SPA artifacts prepared under render/spa/pq and render/router/systemd/."
  else
    # Legacy SPA via fwknop
    # Generate separate keys for encryption and HMAC if not set
    SPA_DIR="$ROOT_DIR/render/spa"
    mkdir -p "$SPA_DIR"
    
    if [[ -z "${SPA_KEY:-}" ]]; then
      SPA_KEY=$(head -c 32 /dev/urandom | base64)
      # Persist key
      if grep -q '^SPA_KEY=' "$ROOT_DIR/.env"; then
        awk -v k="SPA_KEY" -v v="$SPA_KEY" 'BEGIN{FS=OFS="="} $1==k {$0=k"="v} {print}' "$ROOT_DIR/.env" > "$ROOT_DIR/.env.tmp" && mv "$ROOT_DIR/.env.tmp" "$ROOT_DIR/.env"
      else
        echo "SPA_KEY=$SPA_KEY" >> "$ROOT_DIR/.env"
      fi
    fi
    
    if [[ -z "${SPA_HMAC_KEY:-}" ]]; then
      SPA_HMAC_KEY=$(head -c 32 /dev/urandom | base64)
      # Persist HMAC key
      if grep -q '^SPA_HMAC_KEY=' "$ROOT_DIR/.env"; then
        awk -v k="SPA_HMAC_KEY" -v v="$SPA_HMAC_KEY" 'BEGIN{FS=OFS="="} $1==k {$0=k"="v} {print}' "$ROOT_DIR/.env" > "$ROOT_DIR/.env.tmp" && mv "$ROOT_DIR/.env.tmp" "$ROOT_DIR/.env"
      else
        echo "SPA_HMAC_KEY=$SPA_HMAC_KEY" >> "$ROOT_DIR/.env"
      fi
    fi
    
    export SPA_HMAC_KEY
    render "$ROOT_DIR/router/configs/fwknopd.conf" "$ROOT_DIR/render/router/configs/fwknopd.conf"
    render "$ROOT_DIR/router/configs/access.conf" "$ROOT_DIR/render/router/configs/access.conf"
    
    # Generate SPA client configuration
    cat > "$ROOT_DIR/clients/spa-client.conf" <<EOF
# SPA Client Configuration (fwknop)
# Use with: fwknop -A tcp/22 -D <server_ip> -s -k <key> -a <hmac_key> -n <name>
SPA_SERVER_IP=<YOUR_PUB_IP>
SPA_SERVER_PORT=${SPA_PORT}
SPA_KEY=${SPA_KEY}
SPA_HMAC_KEY=${SPA_HMAC_KEY}
SPA_TIMEOUT=${SPA_TIMEOUT}

# Example command:
# fwknop -A tcp/${WG_PORT} -D \${SPA_SERVER_IP} -s -k \${SPA_KEY} -a \${SPA_HMAC_KEY} -n home-secnet
EOF
    echo "[08] SPA (fwknop) enabled. Client config saved to clients/spa-client.conf"
  fi
fi

# Optional: double-hop wg1 to exit node
if [[ "${DOUBLE_HOP_ENABLE:-false}" == "true" ]]; then
  WG2_DIR="$ROOT_DIR/render/wg2"
  mkdir -p "$WG2_DIR"
  if [[ -z "${WG2_PRIVATE_KEY:-}" ]]; then
    echo "[06] Generating wg1 private key..."
    umask 077
    wg genkey > "$WG2_DIR/privatekey"
    WG2_PRIVATE_KEY=$(cat "$WG2_DIR/privatekey")
    # Persist into .env for future renders
    awk -v k="WG2_PRIVATE_KEY" -v v="$WG2_PRIVATE_KEY" 'BEGIN{FS=OFS="="} $1==k {$0=k"="v} {print}' "$ROOT_DIR/.env" > "$ROOT_DIR/.env.tmp" && mv "$ROOT_DIR/.env.tmp" "$ROOT_DIR/.env"
  fi
  export WG2_PRIVATE_KEY
  render "$ROOT_DIR/router/configs/wg1.conf.template" "$ROOT_DIR/render/router/configs/wg1.conf"
  echo "[08] Double-hop enabled. Remember to configure the exit node peer to accept ${WG2_ADDRESS}."
fi

# Enforce QUIC-only if requested: remove any WG UDP allow line from nftables
if [[ "${WRAP_ENFORCE:-false}" == "true" ]]; then
  nftf="$ROOT_DIR/render/router/configs/nftables.conf"
  if [[ -f "$nftf" ]]; then
    # Remove only direct WG accept rules, not SPA-gated ones
    sed -i -E "/udp dport ${WG_PORT}[^@]*$/d" "$nftf"
  fi
fi

# Generate netplan based on ISP_WAN_TYPE
NP_OUT="$ROOT_DIR/render/router/configs/netplan.yaml"
cat > "$NP_OUT" <<EOF
# Generated by render_router_configs.sh
network:
  version: 2
  renderer: networkd
  ethernets:
    ${ROUTER_WAN_IF}:
      optional: true
$(if [[ "$ISP_WAN_TYPE" == "static" ]]; then cat <<EOS
      dhcp4: false
      addresses: [${WAN_STATIC_IP}]
      routes:
        - to: 0.0.0.0/0
          via: ${WAN_STATIC_GW}
      nameservers:
        addresses: [${WAN_STATIC_DNS}]
EOS
else
  cat <<EOS
      dhcp4: true
EOS
fi)
    ${ROUTER_LAN_IF}:
      dhcp4: false
      accept-ra: false
$(if [[ "${USE_VLANS:-false}" == "true" ]]; then cat <<EOS
  vlans:
    ${ROUTER_LAN_IF}.${VLAN_TRUSTED}:
      id: ${VLAN_TRUSTED}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_TRUSTED}/$(prefix_len "$NET_TRUSTED")]
    ${ROUTER_LAN_IF}.${VLAN_IOT}:
      id: ${VLAN_IOT}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_IOT}/$(prefix_len "$NET_IOT")]
    ${ROUTER_LAN_IF}.${VLAN_GUEST}:
      id: ${VLAN_GUEST}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_GUEST}/$(prefix_len "$NET_GUEST")]
    ${ROUTER_LAN_IF}.${VLAN_LAB}:
      id: ${VLAN_LAB}
      link: ${ROUTER_LAN_IF}
      addresses: [${GW_LAB}/$(prefix_len "$NET_LAB")]
EOS
else
  cat <<EOS
      addresses: [${GW_TRUSTED}/$(prefix_len "$NET_TRUSTED")]
EOS
fi)
EOF

# Sample client
CLIENT_PRIV=$(wg genkey)
cat > "$ROOT_DIR/clients/wg-client1.conf" <<EOF
[Interface]
PrivateKey = ${CLIENT_PRIV}
Address = 10.66.66.2/24
DNS = ${WG_DNS}

[Peer]
PublicKey = ${WG_PUBLIC_KEY}
AllowedIPs = ${WG_ALLOWED_IPS}
Endpoint = <YOUR_PUB_IP>:${WG_PORT}
PersistentKeepalive = ${WG_PERSISTENT_KEEPALIVE}
EOF

# Local secure logging configuration
cat > "$ROOT_DIR/render/router/configs/rsyslog-secure.conf" <<EOF
# Secure local logging configuration
# Create secure log directory
\$CreateDirs on
\$DirCreateMode 0750
\$FileCreateMode 0640

# Log all system logs to secure directory
*.* /var/log/secure/system.log

# Log authentication events
auth,authpriv.* /var/log/secure/auth.log

# Log kernel messages
kern.* /var/log/secure/kernel.log

# Log mail events
mail.* /var/log/secure/mail.log

# Log cron events
cron.* /var/log/secure/cron.log

# Log daemon events
daemon.* /var/log/secure/daemon.log

# Log local events
local0.* /var/log/secure/local.log
local1.* /var/log/secure/local.log
local2.* /var/log/secure/local.log
local3.* /var/log/secure/local.log
local4.* /var/log/secure/local.log
local5.* /var/log/secure/local.log
local6.* /var/log/secure/local.log
local7.* /var/log/secure/local.log
EOF

echo "[08] Render complete. Artifacts under render/ and clients/."
